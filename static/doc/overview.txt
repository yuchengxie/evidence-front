
# 新生存证开发手册

&nbsp;

## 目录

  - [1. 架构与组网](show_md.html#overview)
  - [2. 安装与部署](show_md.html#deploy)
  - [3. 源码走读](show_md.html#go_through)
  - [4. 存证 API](show_md.html#api)
  - [5. 定制扩展](show_md.html#porting)

&nbsp;

## 1. 架构与组网

### 1.1 典型组网

基于区块链的存证系统一般采用如下组网方式。

![组网图](doc/pic/network.png)

用户一般在移动终端的 Web 页访问前置机，Web 页还通常包装到一个 app 中。上图中，用户侧访问还可以有其它多种形式，因其本质是 Web 网页，通过浏览器均可正常访问，用户既可以在桌面电脑、移动终端，还有各种支持 Html5 的终端设备的网页访问前置机。

新生链的 “存证服务接入点” 有多个，从原理上讲，链中任一个挖矿节点都可以开放 “存证服务接入” 的功能，但实际开不开放由节点运营者自行决定。“存证服务接入点” 核心功能就是接收存证请求，存证请求是交易请求的一种，须支付 token 用作手续费以确保交易成功。存证服务接入也基于 HTTP 请求，前置机将服务接入节点视作 Web 服务器，发起 RESTful 服务调用即可实现存证请求提交，以及存证结果查询。

&nbsp;

### 1.2 为什么采用前置机

区块链系统支持存证交易由终端用户节点直接提交，而不必借助前置机转接，我们这么设计是为了解决以下若干问题。

其一，证据提交可能涉及多方见证的需求，比方，当存证服务于再就业培训的场合，关联利益方可能有培训机构、人力资源部门、社会保障部门，学员参加再就业培训时的电子签到，需经这 3 个利益相关共同见证，各方均需对电子签到作确认，并附上各方签名以备查验。如果由终端用户直接向区块链系统直接提交存证，上述多方见证的需求就满足不了。

其二，受限于区块链分布式记账的特点，用户直接上链存证也是不合适的。主要因为区块链的处理性能受限，而提交存证往往有高并发要求，区块链系统难以直接为终端用户提供存证；另外，在链上直接存证还有即时确认的问题，如果区块链是公链，以最长链机制来消除软分叉，存证请求从提交到确认往往需要数十分钟，比方 6 次出块作为最终确认，每 2 分钟出一块，6次出块就要 12 分种，很显然，这种确认方式的用户体验会很差。我们用前置机来代理存证操作可解决这些问题，提交到前置机的存证请求将即时签收，返回一个回执，同时前置机还提供相关的查询功能。

其三，向区块链提交存证交易需有钱包模块，钱包管理交易账号的私钥，提交存证时由钱包决定如何支付交易手续费，并提供签名。在许多场景中，终端用户并不拥有一个数字货币钱包，所以，由前置机代理完成存证是合理的。

&nbsp;

### 1.3 存证原理

在区块链上实施存证，主要涉及两项技术：

1. 链上交易不可伪造、不可篡改   
&nbsp;   
这是由区块链的固有特性保证的。一项交易不可伪造，是因为支付方拥有私钥，他用私钥对转出 token 的交易请求实施签名，该交易才算合法，别人不掌握私钥，所以无法伪造交易。在链中已记录的交易不可篡改主要由区块链的共识机制保障，突破算力门槛极难，篡改已确认的交易几乎不可能。   
&nbsp;   
因为链上交易不可伪造、不可篡改，我们设想由自身账号给自身转账 0 个 token，然后在记录交易内容时捎带记录一段文本，交易不可篡改，捎带记录的文本也同样不可篡改，这段文本就是被存证的对象。   
&nbsp;   
当然，上述解释是在原理上，大致扼要的作说明，实际的链上存证稍微复杂些，采用 OP_RETURN 命令字返回链中数据，其记录格式与常规交易还是有些差别的。

2. 哈希摘要算法的确定性与单向性   
&nbsp;   
由于区块链分布式账本的存贮空间限制，将大量原始的证据文本保存到区块链显然不现实。业务惯常做法是：先用消息摘要算法（哈希算法）对证据文本提取散列摘要值（即，哈希值），上链存证的内容改用哈希值，而非原始证据文本。典型情况我们采用 hash256 算法，所得哈希值占用 32 字节，真正在链上存证的是这 32 字节内容。   
&nbsp;   
哈希算法不是加密算法，无法倒推，事实上，从 32 字节恢复大量原始文本在原理上也是不可行的。哈希算法还有两个特性：正向确定性、难被伪造。对于相同输入哈希计算的结果必然相同，这是确定性，难被伪造由算法自身去保障，即，在已知 hash 计算结果的情况下，难以反向拼凑出合乎要求的源头输入文本。因为哈希算法无法倒推、难被伪造，所以，我们在链上存证 32 字节摘要值，完全可以代表原始被存证的内容，表示在存证时刻，被存证内容是就绪了的。   
&nbsp;   
说明，比特币矿机提供 PoW 算力，也依据哈希计算难被伪造的原理，因为难被伪造，只能随机改变输入 nonce 值，通过不断重试来碰撞出合乎要求的 hash 结果值。

总结一下：因为交易不可伪造，所以存证的事件及存证的内容是真实，未被篡改的。因为哈希运算难被伪造，所以，如果证明 hash 结果的真实性，也就证明了消息摘要源头的真实性。

&nbsp;

### 1.4 集合式存证

业界对于被存证的哈希值，还通常采取计算两遍的方式。计算公式如下：

``` python
  hash_result = hash256(hash256(source_message))
```

做两遍哈希有一个明显好处是，它为灵活组装提供可能，比如我们把推导公式优化为：

``` python
  hash_result = hash256(hash256(source_message) + special_message)
```

假设上述 `speial_message` 是在 TEE 设备中生成的，其内容秘不外宣，我们可以在 TEE 外计算出 `hash256(source_message)` 的结果值，然后将此值传入 TEE，由 TEE 中程序将它与 `special_message` 拼接，再计算一遍哈希并返回最后结果。在这个场景中，传入 TEE 的只需是第一遍 hash 计算值，传递 32 字节即可，如果不做这一遍哈希运算，我们可能要向 TEE 传入数 KB 甚到数 MB 内容，用于与 `special_message` 拼接。

上面例子隐含了证据推导链条，依据一次哈希运算结果无法伪造源头，多叠加一次也如此。我们的存证前置机用于接收存证请求，并不是来一次请求就存证一次，而是收集许多次请求，汇总形成一长串消息，对该长串消息做哈希运算，然后将所得哈希值存证到区块链。为描述清晰起见，我们称汇总后的长串消息为 “待存证内容集合”，该集合由若干个 “单次存证” 组成。

这一存证方式的举证路径如下：

>  *因为区块链中记录的 32 字节 hash 值不可伪造，所以 “待存证内容集合” 未经伪造，所以该集合的局部，单次存证也未经伪造。*

然后，单次存证的内容里还有时间、多方见证签名等设计，可从另一维度验证里层的信息真实性。

&nbsp;
